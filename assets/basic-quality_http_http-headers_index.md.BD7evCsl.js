import{_ as n,o,c as l,J as s,w as p,m as i,a as h,aa as d,E as e}from"./chunks/framework.DJCjJe2w.js";const q=JSON.parse('{"title":"HTTP请求头","description":"","frontmatter":{"createTime":"2022/11/09","tag":"HTTP"},"headers":[],"relativePath":"basic-quality/http/http-headers/index.md","filePath":"basic-quality/http/http-headers/index.md","lastUpdated":1672050876000}'),r={name:"basic-quality/http/http-headers/index.md"},c=i("h1",{id:"http请求头",tabindex:"-1"},[h("HTTP请求头 "),i("a",{class:"header-anchor",href:"#http请求头","aria-label":'Permalink to "HTTP请求头"'},"​")],-1),k=d(`<h3 id="_1-1-场景" tabindex="-1">1.1 场景 <a class="header-anchor" href="#_1-1-场景" aria-label="Permalink to &quot;1.1 场景&quot;">​</a></h3><p>如果你有了解过 <code>Content-Disposition</code> 这个 <code>Response Header</code>，那你一定知道，只需要响应头上增加一行，问题就能迎刃而解。</p><h3 id="_1-2-介绍" tabindex="-1">1.2 介绍 <a class="header-anchor" href="#_1-2-介绍" aria-label="Permalink to &quot;1.2 介绍&quot;">​</a></h3><p><strong><code>Content-Disposition</code></strong>：这个响应头可以决定内容是 <strong>预览</strong> 还是 <strong>下载</strong>。</p><p>它支持三种格式的值：</p><ol><li><code>Content-Disposition: inline</code><br> 此时，消息体会以页面的一部分或者整个页面的形式展示。（预览）</li><li><code>Content-Disposition: attachment</code><br> 消息体应该被下载，默认文件名和 <code>url</code> 格式有关。</li><li><code>Content-Disposition: attachment; filename=&quot;filename.jpg&quot;</code><br> 消息体应该被下载，默认文件名可指定。</li></ol><blockquote><p>注：如果需要预览，需要配合适当的 <code>Content-Type</code> 食用；</p></blockquote><h3 id="_1-3-示例" tabindex="-1">1.3 示例 <a class="header-anchor" href="#_1-3-示例" aria-label="Permalink to &quot;1.3 示例&quot;">​</a></h3><p>为此，我特意写了一个 <code>express</code> 小示例。</p><p>大抵是在 <code>express</code> 应用下写了三个路由，如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;摸鱼的春哥&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  blogUrl: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://juejin.cn/user/1714893870865303&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contentDispositionInline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Disposition&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;inline&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contentDispositionFilename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Disposition&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;attachment; filename=&quot;chunge.json&quot;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contentDispositionNoFilename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Disposition&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;attachment&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>然后我分别访问三个路由，效果差异：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b92606d69564a6cb5fd1bdf0c005370~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><h2 id="二、项目升级了-需要客户-清空缓存" tabindex="-1">二、项目升级了，需要客户 <strong>清空缓存</strong> ？ <a class="header-anchor" href="#二、项目升级了-需要客户-清空缓存" aria-label="Permalink to &quot;二、项目升级了，需要客户 **清空缓存** ？&quot;">​</a></h2><h3 id="_2-1-场景" tabindex="-1">2.1 场景 <a class="header-anchor" href="#_2-1-场景" aria-label="Permalink to &quot;2.1 场景&quot;">​</a></h3><p>实施：“客户反馈<code>Bug</code> 还是没修复。”<br> 你：“哥，真修复了，要不你让客户清一下缓存？”<br> 实施：“啊？客户说他不会清……”</p><p>永远不要期望你的客户会进行 <strong>“那些研发才懂”</strong> 的操作。也不要把你的问题，归因到 <strong>浏览器缓存</strong> 上。</p><p><strong>浏览器缓存</strong> 是被发明出来优化用户体验的，并不是被发明出来阻碍用户的。</p><p>因此，理解如何使用 <code>Cache-Control</code> 这个响应头，是前端的必知技能。</p><h3 id="_2-2-介绍" tabindex="-1">2.2 介绍 <a class="header-anchor" href="#_2-2-介绍" aria-label="Permalink to &quot;2.2 介绍&quot;">​</a></h3><p><strong><code>Cache-Control</code></strong>：用来指定缓存机制。</p><p>缓存，作为前端八股文必考知识，相信大家已经耳熟能详。 常见的 <strong><code>Cache-Control</code></strong> 属性如下：</p><table><thead><tr><th>Response Header属性</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>cache-control</td><td>no-store</td><td>不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</td></tr><tr><td>cache-control</td><td>public</td><td>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。）</td></tr><tr><td>cache-control</td><td>private</td><td>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。</td></tr><tr><td>cache-control</td><td>max-age=&lt;1000&gt;</td><td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td></tr></tbody></table><ul><li>不缓存<br> 不缓存是最容易理解，每一次请求都会从服务端重新获取，不进行任何缓存。<br> 此策略只需要赋予 <code>Cache-Control: no-store</code> 响应头即可。</li><li>强缓存<br> 有些资源文件，几乎不会发生变化（比如已经 <code>hash化命名的文件</code>），则可以直接从本地缓存获取，这就是所谓的 <strong>强缓存</strong> ;<br> 通过 <code>cache-control: public/private</code> 或者 <code>cache-control: max-age=&lt;1000&gt;</code> 都可以指定机制为强缓存。</li><li>协商缓存<br> 这是一种更为复杂缓存机制，无法再通过响应头 <strong>简单粗暴地</strong> 指定实现，而是需要前后端协作配合。<br> 简单来说，每次请求资源前前端会写代前一次的响应 <code>hash</code>，问询服务端 <strong>资源是否发生过变化</strong>，从而达到准确缓存的效果。<br> 本文不赘述，如果有兴趣，可以参考此文：<a href="https://juejin.cn/post/7030781324650610695" title="https://juejin.cn/post/7030781324650610695" target="_blank" rel="noreferrer">juejin.cn/post/703078…</a></li></ul><h3 id="_2-3-实际生产如何运用" tabindex="-1">2.3 实际生产如何运用？ <a class="header-anchor" href="#_2-3-实际生产如何运用" aria-label="Permalink to &quot;2.3 实际生产如何运用？&quot;">​</a></h3><ul><li>凡是名称带有 <code>hash</code> 值的资源，一律可以强缓存。<br> （毕竟内容一旦有变化，名称的<code>hash</code> 也跟着变了）</li><li>凡是通过 <code>cdn</code> 引入的第三方库，均建议携带版本信息，这样也可以强缓存。<br> （比如 <code>/xx/xx/jquery.min.js</code> 切换为 <code>jquery@3.6.0/dist/jquery.min.js</code>）</li><li>凡是 <code>html</code>、<code>ico</code> 这类命名固定的文件，建议一律 <strong>不缓存</strong> 或者 <strong>协商缓存</strong>。</li></ul><h2 id="三、我的-cookie-不可能这么可爱" tabindex="-1">三、我的 <code>Cookie</code> 不可能这么可爱 <a class="header-anchor" href="#三、我的-cookie-不可能这么可爱" aria-label="Permalink to &quot;三、我的 \`Cookie\` 不可能这么可爱&quot;">​</a></h2><h3 id="_3-1-场景" tabindex="-1">3.1 场景 <a class="header-anchor" href="#_3-1-场景" aria-label="Permalink to &quot;3.1 场景&quot;">​</a></h3><blockquote><p>&quot;春哥春哥，为啥我登录成功了，请求还是 <code>401</code> ？&quot;</p></blockquote><blockquote><p>&quot;春哥春哥，为啥我存进 <code>cookie</code> 的值取不到？&quot;</p></blockquote><blockquote><p>&quot;春哥春哥，这破 <code>cookie</code> 是不是坏了，浏览器里看明明有值，为啥我访问不了？&quot;</p></blockquote><p>我：“兄弟，你有了解过一个叫 <code>set-cookie</code> 的响应头吗？”</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48bf9bf38d94486498a7b33afd7d7766~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"> 是它！是它！就是它！关于 <code>cookie</code> 的各种异常，全靠它!</p><h3 id="_3-2-介绍" tabindex="-1">3.2 介绍 <a class="header-anchor" href="#_3-2-介绍" aria-label="Permalink to &quot;3.2 介绍&quot;">​</a></h3><p><code>Cookie</code> 曾经是 <code>Web</code> 开发无法绕开的一道门槛，而现在它的存在感越来越弱，但海量的存量项目并不会因为技术的趋势而消失，它们依然很有价值，依然需要维护。</p><p>而 <code>set-cookie</code> 响应头正是 <code>Cookie</code> 体系中最为核心的 <strong>第一主角</strong>。</p><p><strong><code>Set-Cookie</code></strong>: 是一个响应头，服务端赋值，让浏览器端产生 <code>Cookie</code>，并限定 <code>Cookie</code> 的各种特性。</p><p>这些特性就包括：</p><ul><li>过期时限；<code>Expires=&lt;date&gt;</code></li><li>存活周期；<code>Max-Age=&lt;number&gt;</code><br> 在 cookie 失效之前需要经过的秒数。<code>0</code> 或 <code>-1</code> 直接失效；此属性的优先级高于 <code>Expires</code>。</li><li>域名；<code>Domain=&lt;domain-value&gt;</code><br> 指定 <code>cookie</code> 只能在什么域下生成；（允许通配，这个属性主要出于安全性）</li><li>路径；<code>Path=&lt;path-value&gt;</code><br> 比 <code>Domain</code> 更为细致的控制策略，甚至指定了 <code>xx</code> 路径下才能发送 <code>Cookie</code>。</li><li>只在 <code>Https</code> 产生；<code>Secure</code><br> 如果 <code>set-cookie</code> 头中有 <code>Secure</code> 属性，那么浏览器只会在 <code>Https</code> 环境产生和发送 <code>Cookie</code>。</li><li>禁用 <code>js</code> 操作 <code>API</code>；<code>HttpOnly</code><br> 如果 <code>set-cookie</code> 头中有 <code>HttpOnly</code> 属性，那么 <code>Cookie</code> 属性的生成、读写、发送就只能由浏览器通过 &quot;响应头&quot; 控制了，不在允许前端通过 <code>js</code> 操作 <code>Cookie</code>。</li><li>是否允许跨域携带；<code>SameSite=&lt;samesite-value&gt;</code><br> 支持属性包括 <code>Strict</code>、<code>Lax</code>、<code>None</code>，分别表示： <ul><li><code>Strict</code>: 完全不能跨域携带；</li><li><code>Lax</code>: 只允许从外站导航到源站时携带 <code>Cookie</code></li><li><code>None</code>：跨域也行，不限制。</li></ul></li></ul><h3 id="_3-3-开发常见问题分析" tabindex="-1">3.3 开发常见问题分析 <a class="header-anchor" href="#_3-3-开发常见问题分析" aria-label="Permalink to &quot;3.3 开发常见问题分析&quot;">​</a></h3><ul><li><p>为啥你登录成功了，请求还是 <code>401</code>？</p><p>早期非常多的项目，使用 <code>Cookie</code> 作为用户身份识别的手段，比如 <code>Spring MVC</code> 项目就是通过给 <code>Cookie</code> 一个 <code>JSeesionId</code> 的值作为识别，判断你是否出于当前会话。</p><p>而 &quot;登录了，却还 <code>401</code>&quot; 这个现象，如果服务端没有问题的话，多半是 <strong>浏览器其实并未存储Cookie</strong>。</p><p>换个说法，你每次发起请求，服务端都认为你是一次 <strong>新的会话</strong>，和上一次 <strong>登录的你</strong> 并非同一人。</p><p>如果你正处于 <code>http</code> 环境，那你可能需要暂时移除 <code>Secure</code> 属性。</p></li><li><p>存不进、取不出？<br> 先确认 <strong>是否有域的限制</strong>、<strong>是否有路径的限制</strong>、<strong>是否有 <code>HttpOnly</code></strong>?<br> 逐一排查下来，问题不难解决。</p></li></ul>`,41);function E(g,u,b,y,m,F){const a=e("ArticleMetadata"),t=e("ClientOnly");return o(),l("div",null,[c,s(t,null,{default:p(()=>[s(a)]),_:1}),k])}const _=n(r,[["render",E]]);export{q as __pageData,_ as default};
