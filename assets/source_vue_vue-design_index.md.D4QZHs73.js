import{_ as t,o,c as u,J as e,w as n,m as l,a as c,aa as s,E as a}from"./chunks/framework.DJCjJe2w.js";const _=JSON.parse('{"title":"整体设计","description":"","frontmatter":{"createTime":"2022/10/22","tag":"Vue源码"},"headers":[],"relativePath":"source/vue/vue-design/index.md","filePath":"source/vue/vue-design/index.md","lastUpdated":1667281923000}'),h={name:"source/vue/vue-design/index.md"},d=l("h1",{id:"整体设计",tabindex:"-1"},[c("整体设计 "),l("a",{class:"header-anchor",href:"#整体设计","aria-label":'Permalink to "整体设计"'},"​")],-1),m=s('<h2 id="vue3-相比于-vue2-做了哪些优化" tabindex="-1">Vue3 相比于 Vue2 做了哪些优化 <a class="header-anchor" href="#vue3-相比于-vue2-做了哪些优化" aria-label="Permalink to &quot;Vue3 相比于 Vue2 做了哪些优化&quot;">​</a></h2><h3 id="源码结构上面的优化-采用了-monorepo-和-typscript" tabindex="-1">源码结构上面的优化 采用了 monorepo 和 typscript <a class="header-anchor" href="#源码结构上面的优化-采用了-monorepo-和-typscript" aria-label="Permalink to &quot;源码结构上面的优化  采用了  monorepo 和 typscript&quot;">​</a></h3><ul><li>vue2 的源码是托管 src 目录 下 根据功能才分了 compiler core platforms server sfc shared</li><li>vue3 的源码 整体通过 monorepo 维护 不同的模块拆分到 packages 目录下 拆分到颗粒度更细 指责划分更明确 依赖关系也更明显 便于 开发人员 阅读和维护 提高了可维护性</li><li>vue2 是用的 flow 进行 类型检查的 flow 在复杂场景下的支持不好</li><li>vue3 是用的 typscript 重构的</li></ul><h3 id="源码体积的优化" tabindex="-1">源码体积的优化 <a class="header-anchor" href="#源码体积的优化" aria-label="Permalink to &quot;源码体积的优化&quot;">​</a></h3><ul><li>移除一些不常用的 API filter inline-template delete set 等</li><li>引入tree-shaking，可以将无用模块“剪辑”, 仅打包需要的，使打包的整体体积变小了 <ul><li>tree-shaking 的原理也很简单 依赖 es2015 模块语法的静态结构 import export 通过编译阶段的静态分析 找到没有 导入的模块 打上标记 在压缩阶段删除 未使用的模块</li><li>这样 vue3的体积是根据 项目中使用到的功能来变化的</li></ul></li></ul><h3 id="数据劫持的优化" tabindex="-1">数据劫持的优化 <a class="header-anchor" href="#数据劫持的优化" aria-label="Permalink to &quot;数据劫持的优化&quot;">​</a></h3><ul><li>直接 Proxy 替换 Object.defineProperty <ul><li>缺点： 兼容性更低</li></ul></li><li>vue2 使用的 Object.defineProperty 需要递归遍历 对象来达到劫持的深层次变化监听</li><li>vue3 使用 proxy 实现了 增加删除都可以监听到 但是也无法深层次的监听对象的变化 但是是在 proxy 处理器的 getter 中递归响应 好处是： 真正访问到的内部对象才会变成响应式 vue2 是 无脑递归</li></ul><h3 id="编译优化" tabindex="-1">编译优化 <a class="header-anchor" href="#编译优化" aria-label="Permalink to &quot;编译优化&quot;">​</a></h3><ul><li>vue2 的更新 dom 颗粒度是到组件的 虽然保证了更新组件的最小化 但是单个组件内部 依然需要遍历整个 vnode</li><li>vue3 通过 编译阶段 对静态模版的分析 编译生成了 Block Tree <ul><li>Block Tree 是将模版基于 动态节点 指令切割的嵌套区块 每个区块内部的节点结构是固定的 每个区块用一个 Array 来追踪自身包含的 动态节点</li></ul></li><li>vue3 将性能优化到 以 动态节点数量 相关 很大的性能突破</li></ul><h3 id="语法-api-优化" tabindex="-1">语法 API 优化 <a class="header-anchor" href="#语法-api-优化" aria-label="Permalink to &quot;语法 API 优化&quot;">​</a></h3><ul><li>Compostion Api <ul><li>更好的逻辑代码拆分 代码不分散</li><li>复用优势更大</li></ul></li><li>Vue2 options <ul><li>代码过于分散</li><li>多个 mixins 变量命名容易冲突</li></ul></li></ul><h3 id="引入-rfc" tabindex="-1">引入 RFC <a class="header-anchor" href="#引入-rfc" aria-label="Permalink to &quot;引入 RFC&quot;">​</a></h3><ul><li>保证每一个 fearure-request 都是经过团队讨论才会进行开发的</li><li>提升了 稳定性 少走弯路</li></ul><h3 id="diff算法优化" tabindex="-1">diff算法优化 <a class="header-anchor" href="#diff算法优化" aria-label="Permalink to &quot;diff算法优化&quot;">​</a></h3><ul><li>新增了静态标记 如果被标记过的 就不会在重新对比</li><li>vue2 是全量对比</li></ul><h3 id="静态提升" tabindex="-1">静态提升 <a class="header-anchor" href="#静态提升" aria-label="Permalink to &quot;静态提升&quot;">​</a></h3><ul><li>会把静态节点进行局部作用域的提升 再次更新的时候不会循环 会直接取声明的</li><li>vue2 是 无论是否更新 都会重新创建 dom节点然后渲染 cacheHandles 事件监听缓存</li><li>cacheHandlers 是Vue3中提供的事件缓存对象，当 cacheHandlers 开启，会自动生成一个内联函数，同时生成一个静态节点。当事件再次触发时，只需从缓存中调用即可，无需再次更新</li><li>vue2.x中，绑定事件每次触发都要重新生成全新的function去更新，</li></ul><h3 id="ssr优化" tabindex="-1">SSR优化 <a class="header-anchor" href="#ssr优化" aria-label="Permalink to &quot;SSR优化&quot;">​</a></h3><ul><li>当存在大量静态内容时，这些内容会被当作纯字符串推进一个 buffer 里面，即使存在动态的绑定，会通过模版插值潜入进去。这样会比通过虚拟 dmo 来渲染的快上很多。</li><li>当静态内容大到一个量级的时候，会用_createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHtml，就不需要再创建对象，然后根据对象渲染。 支持多根节点组件</li></ul><h2 id="vue3-源码编译过程" tabindex="-1">vue3 源码编译过程 <a class="header-anchor" href="#vue3-源码编译过程" aria-label="Permalink to &quot;vue3 源码编译过程&quot;">​</a></h2><ul><li>vue3 的源码是通过 monorepo 的方式维护的 根据功能不同的模块拆分到 packages 目录下的不同子目录中</li><li>源码通过编译 会构建出不同版本的 Vue.js 它们的应用场景各不相同 <ul><li>有的支持 cdn 直接导入</li><li>有的需要配合打包工具使用</li><li>有的用于服务端的渲染</li></ul></li><li>在源码编译构建过程中 会先收集编译目标 然后执行 并行编译 最终通过 rollup 工具完成单个包的编译</li><li>在运行 rollup 编译单个包的时候 会从每个包的 package.json 中读取相关编译配置 最终编译生成不同的目标文件</li></ul><h2 id="vue3-源码结构" tabindex="-1">vue3 源码结构 <a class="header-anchor" href="#vue3-源码结构" aria-label="Permalink to &quot;vue3 源码结构&quot;">​</a></h2><h3 id="compiler-core" tabindex="-1">compiler-core <a class="header-anchor" href="#compiler-core" aria-label="Permalink to &quot;compiler-core&quot;">​</a></h3><ul><li>与平台无关的编译器核心代码实现</li><li>包含编译器 基础编译流程</li><li>解析模版 生成 ast</li><li>ast 节点的转换</li><li>根据 ast 生成代码</li><li>与平台无关的转换插件</li></ul><h3 id="compiler-dom" tabindex="-1">compiler-dom <a class="header-anchor" href="#compiler-dom" aria-label="Permalink to &quot;compiler-dom&quot;">​</a></h3><ul><li>在浏览器端编译时 使用 compiler-dom 提供的编译器</li><li>专门针对浏览器的转换插件</li></ul><h3 id="compiler-ssr" tabindex="-1">compiler-ssr <a class="header-anchor" href="#compiler-ssr" aria-label="Permalink to &quot;compiler-ssr&quot;">​</a></h3><ul><li>在服务端编译时 所使用的 渲染转换插件</li></ul><h3 id="compiler-sfc" tabindex="-1">compiler-sfc <a class="header-anchor" href="#compiler-sfc" aria-label="Permalink to &quot;compiler-sfc&quot;">​</a></h3><ul><li>处理 .vue 单文件组件 解析 vue 文件</li><li>template style script 解析都是这里实现的</li></ul><h3 id="runtime-core" tabindex="-1">runtime-core <a class="header-anchor" href="#runtime-core" aria-label="Permalink to &quot;runtime-core&quot;">​</a></h3><ul><li>虚拟 DOM 渲染器</li><li>组件实现</li><li>全局的 js api</li></ul><h3 id="runtime-dom" tabindex="-1">runtime-dom <a class="header-anchor" href="#runtime-dom" aria-label="Permalink to &quot;runtime-dom&quot;">​</a></h3><ul><li>对原生 dom api 属性 样式 事件等的管理</li></ul><h3 id="runtime-test" tabindex="-1">runtime-test <a class="header-anchor" href="#runtime-test" aria-label="Permalink to &quot;runtime-test&quot;">​</a></h3><ul><li>测试 runtime-core 用于内部测试</li></ul><h3 id="reactivity" tabindex="-1">reactivity <a class="header-anchor" href="#reactivity" aria-label="Permalink to &quot;reactivity&quot;">​</a></h3><ul><li>响应式系统</li><li>runtime-core 包的依赖</li><li>可以独立使用</li></ul><h3 id="template-explorer" tabindex="-1">template-explorer <a class="header-anchor" href="#template-explorer" aria-label="Permalink to &quot;template-explorer&quot;">​</a></h3><ul><li>调试模版编译输出的工具</li><li>在源码目录中 yarn dev-compiler</li></ul><h3 id="sfc-playground" tabindex="-1">sfc-playground <a class="header-anchor" href="#sfc-playground" aria-label="Permalink to &quot;sfc-playground&quot;">​</a></h3><ul><li>调试 sfc 的工具</li></ul><h3 id="shared" tabindex="-1">shared <a class="header-anchor" href="#shared" aria-label="Permalink to &quot;shared&quot;">​</a></h3><ul><li>多个包共享的实用工具库 size-check</li><li>检测 tree-shaking 后的代码体积</li></ul><h3 id="server-renderer" tabindex="-1">server-renderer <a class="header-anchor" href="#server-renderer" aria-label="Permalink to &quot;server-renderer&quot;">​</a></h3><ul><li>服务端渲染的核心实现</li></ul><h3 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;vue&quot;">​</a></h3><ul><li>面向用户的完整构建</li></ul><h3 id="vue-compat" tabindex="-1">vue-compat <a class="header-anchor" href="#vue-compat" aria-label="Permalink to &quot;vue-compat&quot;">​</a></h3><ul><li>构建版本 可配置兼容 vue2 版本</li></ul>',50);function p(f,v,b,q,x,k){const i=a("ArticleMetadata"),r=a("ClientOnly");return o(),u("div",null,[d,e(r,null,{default:n(()=>[e(i)]),_:1}),m])}const y=t(h,[["render",p]]);export{_ as __pageData,y as default};
