import{_ as r,o as c,c as n,J as e,w as o,m as t,a as u,aa as f,E as a}from"./chunks/framework.DJCjJe2w.js";const B=JSON.parse('{"title":"响应式实现的优化 Vue3.2 版本","description":"","frontmatter":{"createTime":"2022/10/23","tag":"Vue源码"},"headers":[],"relativePath":"source/vue/reactive-principle/implementation-optimized/index.md","filePath":"source/vue/reactive-principle/implementation-optimized/index.md","lastUpdated":1667281923000}'),s={name:"source/vue/reactive-principle/implementation-optimized/index.md"},d=t("h1",{id:"响应式实现的优化-vue3-2-版本",tabindex:"-1"},[u("响应式实现的优化 Vue3.2 版本 "),t("a",{class:"header-anchor",href:"#响应式实现的优化-vue3-2-版本","aria-label":'Permalink to "响应式实现的优化 Vue3.2 版本"'},"​")],-1),p=f('<h2 id="依赖收集的优化" tabindex="-1">依赖收集的优化 <a class="header-anchor" href="#依赖收集的优化" aria-label="Permalink to &quot;依赖收集的优化&quot;">​</a></h2><ul><li>之前每次执行副作用函数 都需要先执行 cleanup 清除依赖 然后在副作用函数执行的过程重新收集依赖 <ul><li>过程涉及大量的对集合 set 对添加和删除操作 存在优化空间</li></ul></li><li>为了减少集合的添加和删除操作 标识了每个依赖集合的状态 比如：新收集的 还是收集过的</li></ul><h2 id="设计的全局变量" tabindex="-1">设计的全局变量 <a class="header-anchor" href="#设计的全局变量" aria-label="Permalink to &quot;设计的全局变量&quot;">​</a></h2><ul><li>effectTrackDepth <ul><li>执行 effect函数的深度</li></ul></li><li>trackOpBit <ul><li>标识依赖的收集状态</li></ul></li><li>maxMarkerBits <ul><li>最大标记的位数</li></ul></li><li>effectTrackDepth</li></ul><h2 id="effect-函数实现优化" tabindex="-1">effect 函数实现优化 <a class="header-anchor" href="#effect-函数实现优化" aria-label="Permalink to &quot;effect 函数实现优化&quot;">​</a></h2><ul><li>内部使用 ReactiveEffect 类创建了 _effect实例 并且让函数返回 runner 指向 ReactiveEffect类的 run 函数</li><li>也就是说在执行副作用函数 effect 的时候 实际执行的就是 run 函数</li><li>收集的依赖也从 effect 函数 变成了 _effect 对象</li><li>当 run 函数执行的时候 cleanup 函数 不是再默认执行 会通过 包装好的函数 fn 执行前 先执行 trackOpBit = 1 &lt;&lt; ++effectTrackDepth 记录 trackOpBit</li><li>然后看递归的深度是否超过了 maxMarkerBirts 如果超过 执行老的 cleanup 逻辑</li><li>没超过 执行 initDepMarkers 给依赖打标记</li></ul><h2 id="优化结果" tabindex="-1">优化结果 <a class="header-anchor" href="#优化结果" aria-label="Permalink to &quot;优化结果&quot;">​</a></h2><ul><li>相比于优化前 每次执行 effect 函数 都需要清空依赖 添加依赖的过程</li><li>优化后 每次执行 effect 函数 标记依赖的状态 不会重复收集已经收集的依赖 执行 effect 函数之后 还会移除已被收集但在新一轮没有被收集的依赖</li><li>优化了减少对于 dep 依赖集合的操作 自然的性能提高了</li></ul><h2 id="trackopbit-的设计" tabindex="-1">trackOpBit 的设计 <a class="header-anchor" href="#trackopbit-的设计" aria-label="Permalink to &quot;trackOpBit 的设计&quot;">​</a></h2><ul><li>标记依赖的 trackOpBit 每次执行计算的时候采用了 左移运算符 trackOpBit = 1 &lt;&lt; ++effectTrackDepth 并且在赋值 的时候做了运算</li><li>为什么要这样 ？ <ul><li>因为 effect 执行会有递归的情况 可以通过这种方式记下每个层级的依赖标记情况</li></ul></li><li>在判断 dep 是否已经收集了当前层的依赖 使用了 wasTracked 函数 <ul><li>内部通过 与运算 的结果是否大于 0 来判断当前层级依赖是否已经收集过了</li></ul></li></ul>',10);function h(_,m,k,x,b,v){const i=a("ArticleMetadata"),l=a("ClientOnly");return c(),n("div",null,[d,e(l,null,{default:o(()=>[e(i)]),_:1}),p])}const q=r(s,[["render",h]]);export{B as __pageData,q as default};
