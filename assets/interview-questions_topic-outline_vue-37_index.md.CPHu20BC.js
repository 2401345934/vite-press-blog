import{_ as p,o,c as r,J as e,w as c,m as a,a as u,aa as n,E as i}from"./chunks/framework.DJCjJe2w.js";const V=JSON.parse('{"title":"三十七个常见Vue面试题","description":"","frontmatter":{"createTime":"2022/11/09","tag":"面试题,Vue"},"headers":[],"relativePath":"interview-questions/topic-outline/vue-37/index.md","filePath":"interview-questions/topic-outline/vue-37/index.md","lastUpdated":1667929081000}'),d={name:"interview-questions/topic-outline/vue-37/index.md"},m=a("h1",{id:"三十七个常见vue面试题",tabindex:"-1"},[u("三十七个常见Vue面试题 "),a("a",{class:"header-anchor",href:"#三十七个常见vue面试题","aria-label":'Permalink to "三十七个常见Vue面试题"'},"​")],-1),h=n('<h2 id="一、谈谈你对mvvm的理解" tabindex="-1">一、谈谈你对MVVM的理解？ <a class="header-anchor" href="#一、谈谈你对mvvm的理解" aria-label="Permalink to &quot;一、谈谈你对MVVM的理解？&quot;">​</a></h2><p>映射关系简化，隐藏controller MVVM在MVC的基础上，把控制层隐藏掉了。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb15f75c96540768cc1a1a6e5be3870~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>Vue不是一个MVVM框架，它是一个视图层框架。</p><p>ViewModal是一个桥梁，将数据和视图进行关联。</p><h2 id="二、谈谈你对vue中响应式数据的理解" tabindex="-1">二、谈谈你对Vue中响应式数据的理解？ <a class="header-anchor" href="#二、谈谈你对vue中响应式数据的理解" aria-label="Permalink to &quot;二、谈谈你对Vue中响应式数据的理解？&quot;">​</a></h2><p>数组和对象类型的值变化的时候，通过<code>defineReactive</code>方法，借助了<code>defineProperty</code>，将所有的属性添加了<code>getter</code>和<code>setter</code>。用户在取值和设置的时候，可以进行一些操作。</p><p>缺陷：只能监控最外层的属性，如果是多层的，就要进行全量递归。</p><p>get里面会做依赖搜集（dep[watcher, watcher]） set里面会做数据更新（notify，通知watcher更新）</p><h2 id="三、vue中如何检测数组的变化" tabindex="-1">三、Vue中如何检测数组的变化？ <a class="header-anchor" href="#三、vue中如何检测数组的变化" aria-label="Permalink to &quot;三、Vue中如何检测数组的变化？&quot;">​</a></h2><p>vue中对数组没有进行defineProperty，而是重写了数组的7个方法。 分别是：</p><ul><li>push</li><li>shift</li><li>pop</li><li>splice</li><li>unshift</li><li>sort</li><li>reverse</li></ul><p>因为这些方法都会改变数组本身。</p><p>数组里的索引和长度是无法被监控的。</p><h2 id="四、vue中如何进行依赖收集的" tabindex="-1">四、Vue中如何进行依赖收集的？ <a class="header-anchor" href="#四、vue中如何进行依赖收集的" aria-label="Permalink to &quot;四、Vue中如何进行依赖收集的？&quot;">​</a></h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f1dafe073304e1ca756cb61845629c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>Vue初始化的时候，挂载之后会进行编译。生成renderFunction。</p><p>当取值的时候，就会搜集watcher，放到dep里面。</p><p>当用户更改值的时候，就会通知watcher，去更新视图。</p><h2 id="五、如何理解vue中的模板编译原理" tabindex="-1">五、如何理解Vue中的模板编译原理？ <a class="header-anchor" href="#五、如何理解vue中的模板编译原理" aria-label="Permalink to &quot;五、如何理解Vue中的模板编译原理？&quot;">​</a></h2><p>这个问题的核心是如何将template转换成render函数。</p><ol><li>将template模块转换成ast语法书 - parserHTML</li><li>对静态语法做标记（某些节点不改变）</li><li>重新生成代码 - codeGen,使用with语法包裹字符串</li></ol><h2 id="六、vue生命周期钩子是如何实现的" tabindex="-1">六、Vue生命周期钩子是如何实现的? <a class="header-anchor" href="#六、vue生命周期钩子是如何实现的" aria-label="Permalink to &quot;六、Vue生命周期钩子是如何实现的?&quot;">​</a></h2><p>Vue的生命周期钩子是回调函数，当创建组件实例的过程中会调用相应的钩子方法。 内部会对钩子进行处理，将钩子函数维护成数组的形式。</p><h2 id="七、vue组件生命周期有哪些" tabindex="-1">七、Vue组件生命周期有哪些？ <a class="header-anchor" href="#七、vue组件生命周期有哪些" aria-label="Permalink to &quot;七、Vue组件生命周期有哪些？&quot;">​</a></h2><ul><li>beforeCreate 在实例初始化之后，数据观测observer 和event、watcher事件配置之前被调用</li><li>created 实例已经创建完成，在这一步，以下配置被完成 <ul><li>数据观测</li><li>属性和方法的运算</li><li>watch/event时间回调</li><li>$el尚未生成</li></ul></li><li>beforeMount 在挂载之前被调用，render尚未被调用</li><li>mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用</li><li>beforeUpdate 数据更新时，被调用，发生在虚拟Dom重新渲染和打补丁之前</li><li>update 由于数据更改导致的虚拟Dom重新渲染和打补丁，在这之后调用</li><li>beforeDestroy 实例销毁之前调用</li><li>destroyed 实例销毁之后调用，调用后Vue实例的所有东西都会被解绑，所有的事件监听会被移除，子实例被销毁，该钩子在服务端渲染期间不被调用</li><li>keep-alive（activated &amp; deactivated）</li></ul><h2 id="八、vue-mixin的使用场景和原理" tabindex="-1">八、vue.mixin的使用场景和原理? <a class="header-anchor" href="#八、vue-mixin的使用场景和原理" aria-label="Permalink to &quot;八、vue.mixin的使用场景和原理?&quot;">​</a></h2><p>Vue的mixin的作用就是抽离公共的业务逻辑，原理类似对象的继承，当组件初始化的时候，会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。 如果混入的数据和本身组件的数据有冲突，采用本身的数据为准。</p><p>缺点：命名冲突、数据来源不清晰</p><h2 id="九、vue的组件data为什么必须是一个函数" tabindex="-1">九、Vue的组件data为什么必须是一个函数? <a class="header-anchor" href="#九、vue的组件data为什么必须是一个函数" aria-label="Permalink to &quot;九、Vue的组件data为什么必须是一个函数?&quot;">​</a></h2><p><code>new Vue</code>是一个单例模式，不会有任何的合并操作，所以根实例不必校验data一定是一个函数。 组件的data必须是一个函数，是为了防止两个组件的数据产生污染。 如果都是对象的话，会在合并的时候，指向同一个地址。 而如果是函数的时候，合并的时候调用，会产生两个空间。</p><h2 id="十、请说明nexttick的原理" tabindex="-1">十、请说明nextTick的原理 <a class="header-anchor" href="#十、请说明nexttick的原理" aria-label="Permalink to &quot;十、请说明nextTick的原理&quot;">​</a></h2><p>nextTick是一个微任务。</p><ul><li>nextTick中的回调是在下次Dom更新循环结束之后执行的延迟回调</li><li>可以用于获取更新后的Dom</li><li>Vue中的数据更新是异步的，使用nextTick可以保证用户定义的逻辑在更新之后执行</li></ul><h2 id="十一、computed和watch的区别是什么" tabindex="-1">十一、computed和watch的区别是什么？ <a class="header-anchor" href="#十一、computed和watch的区别是什么" aria-label="Permalink to &quot;十一、computed和watch的区别是什么？&quot;">​</a></h2><ul><li>computed和watch都基于watcher来实现的。</li><li>computed的属性是具备缓存的，依赖的值不发生变化，对其取值时计算属性方法不会重复执行</li><li>watch是监控值的变化，当值发生改变的时候，会调用回调函数</li></ul><h2 id="十二、vue-set方法是如何实现的" tabindex="-1">十二、Vue.set方法是如何实现的？ <a class="header-anchor" href="#十二、vue-set方法是如何实现的" aria-label="Permalink to &quot;十二、Vue.set方法是如何实现的？&quot;">​</a></h2><ul><li>vue给对象和数组本身都增加了dep属性</li><li>当给对象新增不存在的属性的时候，就会触发对象依赖的watcher去更新</li><li>当修改数组索引的时候，就调用数组本身的splice方法去更新数组</li></ul><h2 id="十三、vue为什么要用虚拟dom" tabindex="-1">十三、Vue为什么要用虚拟Dom <a class="header-anchor" href="#十三、vue为什么要用虚拟dom" aria-label="Permalink to &quot;十三、Vue为什么要用虚拟Dom&quot;">​</a></h2><ul><li>虚拟dom就是用js对象来描述真实Dom，是对真实Dom的抽象</li><li>由于直接操作Dom性能低，但是js层的操作效率高，可以将Dom操作转化成对象操作。最终通过diff算法比对差异进行更新Dom</li><li>虚拟Dom不依赖真实平台环境，可以实现跨平台</li></ul><h2 id="十四、vue的diff算法原理是什么" tabindex="-1">十四、Vue的diff算法原理是什么？ <a class="header-anchor" href="#十四、vue的diff算法原理是什么" aria-label="Permalink to &quot;十四、Vue的diff算法原理是什么？&quot;">​</a></h2><p>Vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式+双指针方式比较</p><ul><li>先比较两个节点是不是相同节点</li><li>相同节点比较属性，复用老节点</li><li>先比较儿子节点，考虑老节点和新节点儿子的情况</li><li>优化比较：头头、尾尾、头尾、尾头</li><li>比对查找，进行复用</li></ul><h2 id="十五、既然vue通过数据劫持可以精准的探测数据变化-为什么还要进行diff检测差异" tabindex="-1">十五、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？ <a class="header-anchor" href="#十五、既然vue通过数据劫持可以精准的探测数据变化-为什么还要进行diff检测差异" aria-label="Permalink to &quot;十五、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？&quot;">​</a></h2><ul><li>响应式数据变化，Vue确实可以在数据变化的时候，响应式系统可以立刻得知。但是如何每个属性都添加watcher的话，性能会非常的差。</li><li>粒度过细，会导致更新不精准</li></ul><p>所以采用watcher + Diff算法来检测差异。</p><h2 id="十六、请说明key的作用和原理" tabindex="-1">十六、请说明key的作用和原理 <a class="header-anchor" href="#十六、请说明key的作用和原理" aria-label="Permalink to &quot;十六、请说明key的作用和原理&quot;">​</a></h2><ul><li>Vue在patch过程中，通过key可以判断两个虚拟节点是否是相同节点。</li><li>没有key会导致更新的时候出问题</li><li>尽量不要采用索引作为key</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd5917790ac4d048c86ffe9983ab707~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h2 id="十七、谈谈对组件的理解" tabindex="-1">十七、谈谈对组件的理解 <a class="header-anchor" href="#十七、谈谈对组件的理解" aria-label="Permalink to &quot;十七、谈谈对组件的理解&quot;">​</a></h2><ul><li>组件化开发能大幅提高应用开发效率、测试性、复用性</li><li>常用的组件化技术：属性、自定义事件、插槽</li><li>降低更新范围，值重新渲染变化的组件</li><li>高内聚、低耦合、单向数据流</li></ul><h2 id="十八、请描述组件的渲染流程" tabindex="-1">十八、请描述组件的渲染流程 <a class="header-anchor" href="#十八、请描述组件的渲染流程" aria-label="Permalink to &quot;十八、请描述组件的渲染流程&quot;">​</a></h2><p>产生组件虚拟节点 -&gt; 创建组件的真实节点 -&gt; 插入到页面</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b060c176af4d41a4abd60dc7edced2d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h2 id="十九、请描述组件的更新流程" tabindex="-1">十九、请描述组件的更新流程 <a class="header-anchor" href="#十九、请描述组件的更新流程" aria-label="Permalink to &quot;十九、请描述组件的更新流程&quot;">​</a></h2><p>属性更新会触发patchVnode方法，组件的虚拟节点会调用prepatch钩子，然后更新属性，更新组件。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5a19f7f110f441faa0aff053e3ed06a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h2 id="二十、异步组件原理" tabindex="-1">二十、异步组件原理 <a class="header-anchor" href="#二十、异步组件原理" aria-label="Permalink to &quot;二十、异步组件原理&quot;">​</a></h2><p>先渲染异步占位符节点 -&gt; 组件加载完毕后调用forceUpdate强制更新。</p><h2 id="二十一、函数组件的优势和原理" tabindex="-1">二十一、函数组件的优势和原理 <a class="header-anchor" href="#二十一、函数组件的优势和原理" aria-label="Permalink to &quot;二十一、函数组件的优势和原理&quot;">​</a></h2><ul><li>函数式组件的特性：无状态、无生命周期、无this。因此性能会高一点。</li></ul><p>正常的一个组件是一个类继承了Vue。</p><p>函数式组件，就是一个普通的函数。</p><h2 id="二十二、组件的传值方式有哪些" tabindex="-1">二十二、组件的传值方式有哪些？ <a class="header-anchor" href="#二十二、组件的传值方式有哪些" aria-label="Permalink to &quot;二十二、组件的传值方式有哪些？&quot;">​</a></h2><ol><li>props和emit:父组件向子组件传递数据，通过prop传递。子组件传递数据给父组件是通过emit: 父组件向子组件传递数据，通过prop传递。子组件传递数据给父组件是通过emit:父组件向子组件传递数据，通过prop传递。子组件传递数据给父组件是通过emit事件</li><li>parent,parent,parent,children获取当前组件的父组件和当前组件的子组件</li><li>attrs和attrs和attrs和listeners 。</li><li>父组件通过provide提供，子组件通过inject注入变量</li><li>$ref获取实例</li><li>eventBus平级组件数据传递</li><li>Vuex</li></ol><h2 id="二十三、-attrs是为了解决什么问题出现的" tabindex="-1">二十三、$attrs是为了解决什么问题出现的？ <a class="header-anchor" href="#二十三、-attrs是为了解决什么问题出现的" aria-label="Permalink to &quot;二十三、$attrs是为了解决什么问题出现的？&quot;">​</a></h2><p>主要作用是为了实现批量传递数据。</p><p>provide/inject更适合应用在插件中，主要实现跨级数据传递。</p><h2 id="二十四、v-for和v-if哪个优先级更高" tabindex="-1">二十四、v-for和v-if哪个优先级更高？ <a class="header-anchor" href="#二十四、v-for和v-if哪个优先级更高" aria-label="Permalink to &quot;二十四、v-for和v-if哪个优先级更高？&quot;">​</a></h2><p>首先，v-for和v-if 不能在同一个标签中使用。</p><p>先处理v-for，再处理v-if。</p><p>如果同时遇到的时候，应该考虑先用计算属性处理数据，在进行v-for，可以减少循环次数。</p><h2 id="二十五、v-mode是如何实现的" tabindex="-1">二十五、v-mode是如何实现的？ <a class="header-anchor" href="#二十五、v-mode是如何实现的" aria-label="Permalink to &quot;二十五、v-mode是如何实现的？&quot;">​</a></h2><p>在组件上用的v-model，是model和callback</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d87fe51a5d24ad396f428175b14fa50~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>在普通元素上用v-model，会生成指令，还可能因为不同的元素：</p><ul><li>生成value和input</li><li>生成change和radio</li><li>生成change和checked</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9457f347c54944e7b6819e21dc8d3896~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>指令在什么时候会调用？</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4aa81c3d92ed454d99153dc9ca6ec019~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>源码：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca5f7c5f41ea4550b8f7604a3d8d4f4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h2 id="二十六、vue的普通slot以及作用域slot的区别" tabindex="-1">二十六、Vue的普通Slot以及作用域Slot的区别 <a class="header-anchor" href="#二十六、vue的普通slot以及作用域slot的区别" aria-label="Permalink to &quot;二十六、Vue的普通Slot以及作用域Slot的区别&quot;">​</a></h2><h3 id="普通插槽" tabindex="-1">普通插槽 <a class="header-anchor" href="#普通插槽" aria-label="Permalink to &quot;普通插槽&quot;">​</a></h3><p>普通插槽是渲染后做替换的工作。父组件渲染完毕后，替换子组件的内容。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5d2edbc5b6145349d6ccecd01cb7a82~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>在模板编译的时候，处理组件中的子节点和slot标签 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508c06da3cea4e2cbb2271a565bbcedc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>在创建元素的时候，用_t()方法方法来替换_v()的内容。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8acfee0c25a34b23a991fe9b85164394~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h3 id="作用域插槽" tabindex="-1">作用域插槽 <a class="header-anchor" href="#作用域插槽" aria-label="Permalink to &quot;作用域插槽&quot;">​</a></h3><p>作用域插槽可以拿到子组件里面的属性。在子组件中传入属性然后渲染。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2515ece3689249efbd205d2fd6dda57c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef974fde9b1841d4bf5f2624d5951bb3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>作用域插槽的编译结果：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a94ce2443aa4eb1809a1de30e52d22b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af45b0d4954642bea25c74cc1d1ce8fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h2 id="二十八、vue-use是干什么的" tabindex="-1">二十八、Vue.use是干什么的？ <a class="header-anchor" href="#二十八、vue-use是干什么的" aria-label="Permalink to &quot;二十八、Vue.use是干什么的？&quot;">​</a></h2><p><code>Vue.use</code>是用来使用插件的。我们可以在插件中扩展全局组件、指令、原型方法等。 会调用<code>install</code>方法将Vue的构建函数默认传入，在插件中可以使用vue，无需依赖vue库</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/031b2b04e9224332b8c8413a4f27f243~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h2 id="二十九、组件写name有啥好处" tabindex="-1">二十九、组件写name有啥好处？ <a class="header-anchor" href="#二十九、组件写name有啥好处" aria-label="Permalink to &quot;二十九、组件写name有啥好处？&quot;">​</a></h2><ul><li>增加name属性，会在components属性中增加组件本身，实现组件的递归调用。</li><li>可以表示组件的具体名称，方便调试和查找对应的组件。</li></ul><h2 id="三十、vue的修饰符有哪些" tabindex="-1">三十、vue的修饰符有哪些？ <a class="header-anchor" href="#三十、vue的修饰符有哪些" aria-label="Permalink to &quot;三十、vue的修饰符有哪些？&quot;">​</a></h2><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li><li>.passive</li><li>.right</li><li>.center</li><li>.middle</li><li>.alt</li></ul><h2 id="三十一、如何理解自定义指令" tabindex="-1">三十一、如何理解自定义指令？ <a class="header-anchor" href="#三十一、如何理解自定义指令" aria-label="Permalink to &quot;三十一、如何理解自定义指令？&quot;">​</a></h2><ul><li>在生成ast语法树时，遇到指令会给当前元素添加directives属性</li><li>通过genDirectives生成指令代码</li><li>在patch前，将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</li><li>当执行cbs对应的钩子时，调用对应指令定义方法</li></ul><h2 id="三十二、keep-alive平时在哪里使用-原理是什么" tabindex="-1">三十二、keep-alive平时在哪里使用？原理是什么？ <a class="header-anchor" href="#三十二、keep-alive平时在哪里使用-原理是什么" aria-label="Permalink to &quot;三十二、keep-alive平时在哪里使用？原理是什么？&quot;">​</a></h2><ul><li>使用keep-alive包裹动态组件时，会对组件进行缓存，避免组件重新创建</li></ul><p>使用有两个场景，一个是动态组件，一个是router-view</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f7bef9d47854a28a8a017be9c243672~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>这里创建了一个白名单和一个黑名单。表明哪些需要需要做缓存，哪些不需要做缓存。以及最大的缓存个数。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/371734825c204f7fb6efbd8b4c764357~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>缓存的是组件的实例，用key和value对象保存。</p><p>加载的时候，监控include和exclude。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42c3bece8594c2c80552394128721d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><p>如果不需要缓存，直接返回虚拟节点。</p><p>如果需要缓存，就用组件的id和标签名，生成一个key，把当前vnode的instance作为value，存成一个对象。这就是缓存列表</p><p>如果设置了最大的缓存数，就删除第0个缓存。新增最新的缓存。</p><p>并且给组件添加一个keepAlive变量为true，当组件初始化的时候，不再初始化。</p><h2 id="三十三、vue-router有几种钩子函数-执行流程如何" tabindex="-1">三十三、vue-router有几种钩子函数？执行流程如何？ <a class="header-anchor" href="#三十三、vue-router有几种钩子函数-执行流程如何" aria-label="Permalink to &quot;三十三、vue-router有几种钩子函数？执行流程如何？&quot;">​</a></h2><p>钩子函数有三种：</p><ul><li>全局守卫</li><li>路由守卫</li><li>组件守卫</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32a1543889ee492b946868f4adeb5365~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><h2 id="三十四、vuerouter的两种模式的区别" tabindex="-1">三十四、vuerouter的两种模式的区别 <a class="header-anchor" href="#三十四、vuerouter的两种模式的区别" aria-label="Permalink to &quot;三十四、vuerouter的两种模式的区别&quot;">​</a></h2><ul><li>vue-router中有三种模式，分别是hash、history、abstract</li><li>abstract在不支持浏览器的API换景使用</li><li>hash模式兼容性好，但是不美观，不利于SEO</li><li>history美观，historyAPI+popState，但是刷新会出现404</li></ul><h2 id="三十五、谈谈vue的性能优化有哪些" tabindex="-1">三十五、谈谈Vue的性能优化有哪些？ <a class="header-anchor" href="#三十五、谈谈vue的性能优化有哪些" aria-label="Permalink to &quot;三十五、谈谈Vue的性能优化有哪些？&quot;">​</a></h2><ul><li>数据层级不要过深，合理的设置响应式数据</li><li>使用数据时，缓存值的结果，不频繁取值</li><li>合理设置key</li><li>v-show(频繁切换性能高)和v-if的合理使用</li><li>控制组件的粒度 -&gt; Vue采用组件级别更新</li><li>采用函数式组件 -&gt; 函数式组价开销低</li><li>采用异步组件 -&gt; 借助webpack的分包策略</li><li>使用keep-alive来缓存组件</li><li>虚拟滚动、时间分片等策略</li><li>打包优化</li></ul><h2 id="三十六、谈谈你对vuex的理解" tabindex="-1">三十六、谈谈你对Vuex的理解？ <a class="header-anchor" href="#三十六、谈谈你对vuex的理解" aria-label="Permalink to &quot;三十六、谈谈你对Vuex的理解？&quot;">​</a></h2><p>Vuex是专门为vue提供的全局状态管理系统，用于多个组件中的数据共享、数据缓存。</p><p>问题：无法持久化。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34588bd2f1a446e394cd360acb806fd1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><ul><li>mutation 主要修改状态，同步执行</li><li>action 执行业务代码，方便复用，逻辑可以为异步。不能直接修改状态。</li></ul><h2 id="三十七、vue中使用了哪些设计模式" tabindex="-1">三十七、vue中使用了哪些设计模式？ <a class="header-anchor" href="#三十七、vue中使用了哪些设计模式" aria-label="Permalink to &quot;三十七、vue中使用了哪些设计模式？&quot;">​</a></h2><ul><li>单例模式：new多次，只有一个实例</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eda03992e4a40abab75781d03102411~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png"></p><ul><li>工场模式：传入参数就可以创建实例（虚拟节点的创建）</li><li>发布订阅模式：eventBus</li><li>观察者模式：watch和dep</li><li>代理模式：_data属性、proxy、防抖、节流</li><li>中介者模式：vuex</li><li>策略模式</li><li>外观模式</li></ul>',135);function s(f,b,v,k,g,q){const l=i("ArticleMetadata"),t=i("ClientOnly");return o(),r("div",null,[m,e(t,null,{default:c(()=>[e(l)]),_:1}),h])}const j=p(d,[["render",s]]);export{V as __pageData,j as default};
