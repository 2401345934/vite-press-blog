import{_ as r,o as c,c as u,J as e,w as o,m as l,a as h,aa as s,E as a}from"./chunks/framework.DJCjJe2w.js";const v=JSON.parse('{"title":"watch API 的实现原理","description":"","frontmatter":{"createTime":"2022/10/24","tag":"Vue源码"},"headers":[],"relativePath":"source/vue/watch/realize-principle/index.md","filePath":"source/vue/watch/realize-principle/index.md","lastUpdated":1667281923000}'),n={name:"source/vue/watch/realize-principle/index.md"},d=l("h1",{id:"watch-api-的实现原理",tabindex:"-1"},[h("watch API 的实现原理 "),l("a",{class:"header-anchor",href:"#watch-api-的实现原理","aria-label":'Permalink to "watch API 的实现原理"'},"​")],-1),f=s('<h2 id="watch-api-用法" tabindex="-1">watch API 用法 <a class="header-anchor" href="#watch-api-用法" aria-label="Permalink to &quot;watch API 用法&quot;">​</a></h2><ul><li>watch API 可以监听一个 getter 函数 但是必须返回一个响应式对象 <ul><li>当响应式对象更新后 会执行对应的回调函数</li></ul></li><li>watch API 也可以直接监听一个响应式对象 <ul><li>当响应式对象更新后 会执行对应的回调函数</li></ul></li><li>watch API 可以直接监听多个响应式对象 数组的形式 任意一个响应式对象更新后 都会执行回调函数</li></ul><h2 id="watch-api-实现原理" tabindex="-1">watch API 实现原理 <a class="header-anchor" href="#watch-api-实现原理" aria-label="Permalink to &quot;watch API 实现原理&quot;">​</a></h2><ul><li>当监听对象或者函数发生变化的时候 监听器自动执行某个回调函数</li><li>watch 函数 拥有三个参数 <ul><li>source 表示监听的数据源</li><li>cb 表示数据变化后执行的回调函数</li><li>options 一些配置项</li></ul></li><li>watch 函数 内部调用了 doWatch 函数 <ul><li>调用前会在非生产环境判断第二个参数 cb 是不是 函数 不是发出警告</li><li>告诉用户 应该使用 watchEffect API</li></ul></li></ul><h3 id="标准化-source" tabindex="-1">标准化 source <a class="header-anchor" href="#标准化-source" aria-label="Permalink to &quot;标准化 source&quot;">​</a></h3><ul><li>source 可以是 getter 函数 也可以是响应式对象 甚至是响应式对象数组 <ul><li>所以需要标准化 source</li></ul></li><li>source 标准化主要是根据 source 类型 生成标准化后的 getter 函数</li><li>如果 source 是 ref 对象 创建一个访问 source.value 的 getter 函数</li><li>如果 source是 reactive 对象 创建一个访问 source 的 getter 函数 设置 deep 为 true</li><li>如果 source 是一个函数 进一步判断第二个参数 cb 是否存在</li><li>如果 source 是一个数组 生成的 getter 函数内部通过 source.map 函数映射出有一个新的数组 会判断每个数组元素类型</li><li>如果 source 不满足上面条件 则在非生产环境下 发出警告 source 类型不合法</li><li>如果 deep 为 true 生成的 getter 函数被 traverse 函数包装一个</li></ul><h3 id="traverse" tabindex="-1">traverse <a class="header-anchor" href="#traverse" aria-label="Permalink to &quot;traverse&quot;">​</a></h3><ul><li>通过递归的方式访问 value 的每一个子属性</li><li>deep 属于 watcher 的一个配置选项</li></ul><h3 id="创建-job" tabindex="-1">创建 job <a class="header-anchor" href="#创建-job" aria-label="Permalink to &quot;创建 job&quot;">​</a></h3><ul><li>处理完 watch 第一个 参数 source 之后 开始处理 cb</li><li>cb 是一个回调函数 有三个参数 <ul><li>newValue : 新值</li><li>oldValue : 老值</li><li>onInvalidate : 注册的无效回调函数</li></ul></li><li>如果cb 存在 会先执行 effect.run 函数求的新值 实例就是执行前面创建的 getter 函数求新值</li><li>进行判断 如果 deep 深度或者 是 forckTrigger 强制更新 或者 新旧值发生了变化 <ul><li>执行回调函数 cb 传入参数 newValue oldValue</li><li>第一次执行的时候如果旧值没变化 就是 undefined</li><li>执行完回调函数 cb 后 再把 oldValue 更新成 newValue 为了做下一次的对比</li></ul></li></ul><h3 id="创建-scheduler" tabindex="-1">创建 scheduler <a class="header-anchor" href="#创建-scheduler" aria-label="Permalink to &quot;创建 scheduler&quot;">​</a></h3><ul><li>scheduler 创建逻辑收到了第三个参数 options 中的 flush 的值影响 有三种状态 决定 watcher 回调函数执行时机 <ul><li>flush 是 sync 表示是一个同步的 watcher 数据变化同步执行 回调函数</li><li>flush 是 post 表示 回调函数通过 queuePostRenderEffect 方式在组件更新之后执行</li><li>flush 是 pre 表示 回调函数通过 queuePreFlushCb 方式在组件更新之前执行 如果组件没挂载 就在组件挂载之前通过一定的调度执行</li></ul></li></ul><h3 id="创建-effect" tabindex="-1">创建 effect <a class="header-anchor" href="#创建-effect" aria-label="Permalink to &quot;创建 effect&quot;">​</a></h3><ul><li>wachter 内部都会 创建 effect 对象</li></ul><h4 id="effect-run-的执行" tabindex="-1">effect.run 的执行 <a class="header-anchor" href="#effect-run-的执行" aria-label="Permalink to &quot;effect.run 的执行&quot;">​</a></h4><ul><li>当回调函数 cb 存在 immediate 为 false 首次执行 effect.run 函数求 旧值</li><li>函数内部执行 getter 函数 访问响应式数据做依赖收集</li><li>此时的 activeEffect 就是 wacher 内部创建的 effect 对象 后续数据更新的时候 就可以触发 effect 对象的 scheduler 函数 执行 job 函数</li></ul><h4 id="配置了-immediate" tabindex="-1">配置了 immediate <a class="header-anchor" href="#配置了-immediate" aria-label="Permalink to &quot;配置了 immediate&quot;">​</a></h4><ul><li>创建完 wacher 就会立刻直接 job 函数</li><li>oldValue 还是初始值 在 job 执行时候也会执行 effect.run</li><li>进而执行 getter 函数 做依赖收集 求的新值</li></ul><h3 id="返回销毁函数" tabindex="-1">返回销毁函数 <a class="header-anchor" href="#返回销毁函数" aria-label="Permalink to &quot;返回销毁函数&quot;">​</a></h3><ul><li>会返回一个 销毁函数 是 watch 执行后返回的函数 可以通过调用 来停止对数据的监听</li><li>销毁函数 内部会执行 effect.stop 函数 让 effect 失活 清理 effect 的相关依赖 <ul><li>就可以停止了对数据的监听</li><li>如果在组件注册的 watcher 也会移除组件 effects 对 effect 饮用</li></ul></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>watch 内部设计很巧妙 可以监听数据的变化 内部创建了 effect 对象</li><li>首次执行 effect.run 做依赖收集 然后在数据发生变化的时候</li><li>以某种调度方式执行回调函数</li></ul>',22);function b(m,p,w,_,P,q){const i=a("ArticleMetadata"),t=a("ClientOnly");return c(),u("div",null,[d,e(t,null,{default:o(()=>[e(i)]),_:1}),f])}const A=r(n,[["render",b]]);export{v as __pageData,A as default};
