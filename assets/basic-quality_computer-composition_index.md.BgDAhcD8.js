import{_ as p,o as l,c as o,J as s,w as r,m as i,a as n,aa as h,E as a}from"./chunks/framework.DJCjJe2w.js";const c="/vite-press-blog/assets/computer-composition1.BzuTJeD4.webp",m="/vite-press-blog/assets/computer-composition2.DJotal0q.webp",d="/vite-press-blog/assets/computer-composition3.CQ8ViMle.webp",k="/vite-press-blog/assets/computer-composition4.DI12XjCp.webp",u="/vite-press-blog/assets/computer-composition5.CcTWXKTA.webp",b="/vite-press-blog/assets/computer-composition6.0cDATxHS.webp",_="/vite-press-blog/assets/computer-composition7.CHG3OeYs.webp",g="/vite-press-blog/assets/computer-composition8.C85YGDTC.webp",C="/vite-press-blog/assets/computer-composition9.BrwFMGPE.webp",E="/vite-press-blog/assets/computer-composition10.MNAKS4gp.webp",q="/vite-press-blog/assets/computer-composition11.CIaXvNoe.webp",P="/vite-press-blog/assets/computer-composition12.CQ2cJRv0.webp",y="/vite-press-blog/assets/computer-composition13.6MmO6XEH.webp",v="/vite-press-blog/assets/computer-composition14.Cm8RGSBW.webp",f="/vite-press-blog/assets/computer-composition30.DiTbDMsl.webp",x="/vite-press-blog/assets/computer-composition40.c5iLGR0Z.webp",F="/vite-press-blog/assets/computer-composition15.pYiM2DGa.webp",A="/vite-press-blog/assets/computer-composition16.4uGcPn2S.webp",I="/vite-press-blog/assets/computer-composition17.z5-LTpiW.webp",D="/vite-press-blog/assets/computer-composition18.DG52AVei.webp",w="/vite-press-blog/assets/computer-composition19.BCXqp9Pm.webp",O="/vite-press-blog/assets/computer-composition20.C9PZ4p5S.webp",R="/vite-press-blog/assets/computer-composition21.Z8j3VtZV.webp",B="/vite-press-blog/assets/computer-composition22.dQ4RGsOF.webp",M="/vite-press-blog/assets/computer-composition23.BV9Q8MtC.webp",U="/vite-press-blog/assets/computer-composition24.BvCI1NWr.webp",T="/vite-press-blog/assets/computer-composition25.DLkyJVen.webp",S="/vite-press-blog/assets/computer-composition26.DJBH2n0G.webp",V="/vite-press-blog/assets/computer-composition27.CVYgm2FR.webp",$=JSON.parse('{"title":"计算机组成原理","description":"","frontmatter":{"createTime":"2022/10/26","tag":"计算机"},"headers":[],"relativePath":"basic-quality/computer-composition/index.md","filePath":"basic-quality/computer-composition/index.md","lastUpdated":1667281923000}'),J={name:"basic-quality/computer-composition/index.md"},G=i("h1",{id:"计算机组成原理",tabindex:"-1"},[n("计算机组成原理 "),i("a",{class:"header-anchor",href:"#计算机组成原理","aria-label":'Permalink to "计算机组成原理"'},"​")],-1),N=h('<h2 id="_1、计算机的工作原理" tabindex="-1">1、计算机的工作原理 <a class="header-anchor" href="#_1、计算机的工作原理" aria-label="Permalink to &quot;1、计算机的工作原理&quot;">​</a></h2><p>首先，计算机最基本的5大组成部分如下图，分别为：输入设备(比如键盘), 存储器(比如内存), 运算器(cpu), 控制器(cpu), 输出设备(显示器)。 <img src="'+c+'" alt="图片"></p><p>我们来看二进制代码 0000，0000，000000010000 其结果为：11101 在早期的计算机里，cpu如何知道I/O设备已经完成任务呢?比如说怎么知道I/O设备已经读取完一个文件的数据呢?CPU会不断查询I/O设备是否已经准备好。这时，cpu就处于等待状态。也就是cpu工作的时候，I/O系统是不工作的，I/O系统工作，cpu是不工作。</p><h2 id="工作原理如下" tabindex="-1">工作原理如下 <a class="header-anchor" href="#工作原理如下" aria-label="Permalink to &quot;工作原理如下&quot;">​</a></h2><h3 id="_1-1-控制器-控制输入设备-指令流向内存" tabindex="-1">1.1 控制器 ---&gt; 控制输入设备 ----&gt; 指令流向内存 <a class="header-anchor" href="#_1-1-控制器-控制输入设备-指令流向内存" aria-label="Permalink to &quot;1.1 控制器 ---&gt; 控制输入设备 ----&gt; 指令流向内存&quot;">​</a></h3><p>当我们输入数据的时候，cpu里的控制器会让输入设备把这些指令存储到存储器(内存)上。 <img src="'+m+'" alt="图片"></p><h3 id="_1-2-控制器分析指令-控制存储器-把数据送到运算器" tabindex="-1">1.2 控制器分析指令 ---&gt; 控制存储器 ---&gt; 把数据送到运算器 <a class="header-anchor" href="#_1-2-控制器分析指令-控制存储器-把数据送到运算器" aria-label="Permalink to &quot;1.2 控制器分析指令 ---&gt; 控制存储器 ---&gt; 把数据送到运算器&quot;">​</a></h3><p>控制器分析指令之后， 此时让存储器把数据发送到运算器里(控制器和运算器都在cpu里面) 这里需要注意，存储器既能存储数据，还能存储指令 <img src="'+d+'" alt="图片"></p><h3 id="_1-3-控制器控制运算器做数据的运算-并且将运算结果返回存储器" tabindex="-1">1.3 控制器控制运算器做数据的运算 并且将运算结果返回存储器 <a class="header-anchor" href="#_1-3-控制器控制运算器做数据的运算-并且将运算结果返回存储器" aria-label="Permalink to &quot;1.3 控制器控制运算器做数据的运算 并且将运算结果返回存储器&quot;">​</a></h3><p><img src="'+k+'" alt="图片"></p><h3 id="_1-4-控制器控制存储器将结果返回给输出设备" tabindex="-1">1.4 控制器控制存储器将结果返回给输出设备 <a class="header-anchor" href="#_1-4-控制器控制存储器将结果返回给输出设备" aria-label="Permalink to &quot;1.4 控制器控制存储器将结果返回给输出设备&quot;">​</a></h3><p><img src="'+u+'" alt="图片"></p><p>从接下来，我们更近一步，看看计算机内部，CPU是怎么跟存储器交互的。</p><h2 id="_2、cpu及其工作过程" tabindex="-1">2、CPU及其工作过程 <a class="header-anchor" href="#_2、cpu及其工作过程" aria-label="Permalink to &quot;2、CPU及其工作过程&quot;">​</a></h2><p>CPU中比较重要的两个部件是运算器和控制器，我们先来看看运算器的主要作用</p><h3 id="_2-1-运算器主要部件" tabindex="-1">2.1 运算器主要部件 <a class="header-anchor" href="#_2-1-运算器主要部件" aria-label="Permalink to &quot;2.1 运算器主要部件&quot;">​</a></h3><p><img src="'+b+'" alt="图片"></p><p>如上图，运算器里最重要的部件是ALU，中文叫算术逻辑单元，用来进行算术和逻辑运算的。其它的MQ,ACC这些我们不用管了，是一些寄存器。</p><h3 id="_2-2-控制器主要部件" tabindex="-1">2.2 控制器主要部件 <a class="header-anchor" href="#_2-2-控制器主要部件" aria-label="Permalink to &quot;2.2 控制器主要部件&quot;">​</a></h3><p><img src="'+_+'" alt="图片"></p><p>控制器中最重要的部件是CU（控制单元），只要是分析指令，给出控制信号。 IR（指令寄存器），存放当前需要执行的指令 PC存放的指令的地址。</p><h3 id="_2-3-举例-取数指令执行过程" tabindex="-1">2.3 举例 - 取数指令执行过程 <a class="header-anchor" href="#_2-3-举例-取数指令执行过程" aria-label="Permalink to &quot;2.3 举例 - 取数指令执行过程&quot;">​</a></h3><p><img src="'+g+'" alt="图片"></p><h3 id="首先-是取指令的过程如下" tabindex="-1">首先，是取指令的过程如下 <a class="header-anchor" href="#首先-是取指令的过程如下" aria-label="Permalink to &quot;首先，是取指令的过程如下&quot;">​</a></h3><p><img src="'+C+'" alt="图片"></p><ul><li><p>第一步，PC，也就是存放指令地址的地方，我们要知道下一条指令是什么，就必须去存储器拿，CPU才知道接下来做什么。PC去了存储器的MAR拿要执行的指令地址，MAR（存储器里专门存指令地址的地方）</p></li><li><p>第二步和第三步，MAR去存储体内拿到指令之后，将指令地址放入MDR(存储器里专门存数据的地方)</p></li><li><p>第四步MDR里的数据返回到IR里面，IR是存放指令的地方，我们把刚才从存储体里拿的指令放在这里 然后，分析指令，执行指令的过程如下</p></li><li><p>第五步， IR将指令放入CU中，来分析指令，比如说分析出是一个取数指令，接着就要执行指令了（这里取数指令，其实就是一个地址码，按着这个地址去存储体取数据）</p></li><li><p>第六步，第七步 IR就会接着去找存储体里的MAR（存储地址的地方），MAR就根据取数指令里的地址吗去存储体里去数据</p></li><li><p>第八步，取出的数据返回给MDR（存放数据的地方）</p></li><li><p>第九步，MDR里的数据放到运算器的寄存器里，这里的取指令的过程结束了。 来个插曲，我们知道数据在内存里是二进制存着，也就是0和1, 0和1怎么用表示呢？ 我们拿其中一种存储0和1的方式来说明</p></li><li><p>电容是否有电荷，有电荷代表1，无电荷代表0</p></li><li><p>如下图 <img src="'+E+'" alt="图片"><img src="'+q+'" alt="图片"></p></li></ul><h2 id="_3、计算机编程语言" tabindex="-1">3、计算机编程语言 <a class="header-anchor" href="#_3、计算机编程语言" aria-label="Permalink to &quot;3、计算机编程语言&quot;">​</a></h2><p>我们看看机器语言，怎么表示存放一个数的指令，例如下图 <img src="'+P+'" alt="图片"></p><ul><li>其中第一个0000，表示的是汇编语言里的LOAD，也就是加载，加载什么呢</li><li>加载地址000000010000上的数据到第二个0000（寄存器的位置）。 接下来，我们看看如果是汇编语言怎么表示 <img src="'+y+'" alt="图片"></li></ul><p>LOAD A, 16意思是将存储体内的16号单元数据，放到寄存器地址A中 ADD C, A, B意思是将寄存器里的A,B数据相加，得到C STORE C, 17意思是将寄存器里的数据存到存储体17号单元内 最后，我们看看怎么用高级语言表示 <img src="'+v+'" alt="图片"></p><p>高级语言是不是很简单，就一个a+b，你都不用去考虑寄存器，存储体这些事。 这部分的总结</p><h3 id="高级语言一般有两种方式转换为机器语言" tabindex="-1">高级语言一般有两种方式转换为机器语言 <a class="header-anchor" href="#高级语言一般有两种方式转换为机器语言" aria-label="Permalink to &quot;高级语言一般有两种方式转换为机器语言&quot;">​</a></h3><ul><li>一种是直接借助编译器，将高级语言转换为二进制代码，比如c，这样c运行起来就特别快，因为编译后是机器语言，直接就能在系统上跑，但问题是，编译的速度可能会比较慢。</li><li>一种是解释性的，比如 js，是将代码翻译一行成机器语言（中间可能会先翻译为汇编代码或者字节码），解释一行，执行一行 需要注意的是，按照第一种将大量的高级代码翻译为机器语言，这其中就有很大的空间给编译器做代码优化，解释性语言就很难做这种优化，但是在v8引擎中，js还是要被优化的，在编译阶段（代码分编译和执行两个阶段）会对代码做一些优化，编译后立即执行的方式通常被称为 JIT (Just In Time) Comipler。</li></ul><h2 id="_4、进制转换" tabindex="-1">4、进制转换 <a class="header-anchor" href="#_4、进制转换" aria-label="Permalink to &quot;4、进制转换&quot;">​</a></h2><p>接下来4.3这个小节会解释为什么0.1 + 0.2 等于0.3</p><h3 id="_4-1-二进制如何转化为十进制" tabindex="-1">4.1 二进制如何转化为十进制 <a class="header-anchor" href="#_4-1-二进制如何转化为十进制" aria-label="Permalink to &quot;4.1 二进制如何转化为十进制&quot;">​</a></h3><p>例如2进制101.1如何转化为10进制。（有些同学觉得可以用parseInt(&#39;101.1&#39;, 2)，这个是不行的，因为parseInt返回整数） 转化方法如下： <img src="'+f+'" alt="图片"></p><p>上图的规则是什么呢？ 二进制的每个数去乘以2的相应次方,注意小数点后是乘以它的负相应次方。 再举一个例子你就明白了， 二进制1101转为十进制 <img src="'+x+'" alt="图片"></p><h3 id="_4-2-十进制整数转为二进制" tabindex="-1">4.2 十进制整数转为二进制 <a class="header-anchor" href="#_4-2-十进制整数转为二进制" aria-label="Permalink to &quot;4.2 十进制整数转为二进制&quot;">​</a></h3><p>JS里面可以用toString(2)这个方法来转换。如果要用通用的方法，例如：将十进制数（29）转换成二进制数， 算法如下：</p><ul><li>把给定的十进制数29除以2，商为14，所得的余数1是二进制数的最低位的数码</li><li>再将14除以2，商为7，余数为0</li><li>再将7除以2，商为3，余数为1，再将3除以2，商为1，余数为1</li><li>再将1除以2，商为0，余数为1是二进制数的最高位的数码 <img src="'+F+'" alt="图片"></li></ul><h3 id="_4-3-十进制小数转为二进制" tabindex="-1">4.3 十进制小数转为二进制 <a class="header-anchor" href="#_4-3-十进制小数转为二进制" aria-label="Permalink to &quot;4.3 十进制小数转为二进制&quot;">​</a></h3><p>方式是采用“乘2取整，顺序排列”法。具体做法是：</p><ul><li>用2乘十进制小数，可以得到积，将积的整数部分取出-</li><li>再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出-</li><li>如此进行，直到积中的小数部分为零，或者达到所要求的精度为止 我们具体举一个例子</li></ul><h3 id="如-十进制-0-25-转为二进制" tabindex="-1">如: 十进制 0.25 转为二进制 <a class="header-anchor" href="#如-十进制-0-25-转为二进制" aria-label="Permalink to &quot;如: 十进制 0.25 转为二进制&quot;">​</a></h3><ul><li>0.25 * 2 = 0.5 取出整数部分：0</li><li>0.5 <em>2 = 1.0 取出整数部分1 即十进制0.25的二进制为 0.01 ( 第一次所得到为最高位,最后一次得到为最低位) 此时我们可以试试十进制0.1和0.2如何转为二进制 0.1(十进制) = 0.0001100110011001(二进制) 十进制数0.1转二进制计算过程： 0.1</em>2＝0.2……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。 0.2<em>2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。 0.4</em>2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。 0.8<em>2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。 0.6</em>2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。 0.2<em>2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。 0.4</em>2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。 0.8<em>2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。 0.6</em>2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。 0.2<em>2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。 0.4</em>2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。 0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。 …… …… 所以，得到的整数依次是：“0”，“0”，“0”，“1”，“1”，“0”，“0”，“1”，“1”，“0”，“0”，“1”……。 由此，大家肯定能看出来，整数部分出现了无限循环。 复制代码</li></ul><h3 id="接下来看0-2" tabindex="-1">接下来看0.2 <a class="header-anchor" href="#接下来看0-2" aria-label="Permalink to &quot;接下来看0.2&quot;">​</a></h3><p>0.2化二进制是 0.2<em>2=0.4,整数位为0 0.4</em>2=0.8,整数位为0 0.8<em>2=1.6,整数位为1,去掉整数位得0.6 0.6</em>2=1.2,整数位为1,去掉整数位得0.2 0.2<em>2=0.4,整数位为0 0.4</em>2=0.8.整数位为0 就这样推下去！小数*2整,一直下去就行 这个数整不断 0.0011001 复制代码 所以0.1和0.2都无法完美转化为二进制，所以它们相加当然不是0.3了</p><h2 id="_5、定点数和浮点数" tabindex="-1">5、定点数和浮点数 <a class="header-anchor" href="#_5、定点数和浮点数" aria-label="Permalink to &quot;5、定点数和浮点数&quot;">​</a></h2><p>首先，什么是定点数呢？</p><h3 id="_5-1-定点数" tabindex="-1">5.1 定点数 <a class="header-anchor" href="#_5-1-定点数" aria-label="Permalink to &quot;5.1 定点数&quot;">​</a></h3><p><img src="'+A+'" alt="图片"></p><p>如上图，举例纯整数的二进制1011和-1011，如果是整数，符号位用0表示，如果是负数符号为用1表示 <img src="'+I+'" alt="图片"></p><p>同理，纯小数表示举例如下： <img src="'+D+'" alt="图片"></p><p>那如果不是纯小数或者纯整数，该怎么表示呢？ 比如10.1, 可以乘以一个比例因子，将10.1 ---&gt; 101 比例因子是10, 或者10.1 ---&gt; 0.101比例因子是100 定点数很简单，接下来我们介绍浮点数，再JS里面，数字都是用双精度的浮点数，所以学习浮点数对我们理解JS的数字有帮助。</p><h3 id="_5-2-浮点数" tabindex="-1">5.2 浮点数 <a class="header-anchor" href="#_5-2-浮点数" aria-label="Permalink to &quot;5.2 浮点数&quot;">​</a></h3><p>浮点数怎么表示呢？ <img src="'+w+'" alt="图片"></p><p>上面是十进制的科学计数法，从中我们需要了解几个概念，一个是尾数，基数和阶码</p><ul><li>尾数必须是纯小数，所以上图中1.2345不满足尾数的格式，需要改成0.12345</li><li>基数，在二进制里面是2</li><li>阶码就是多少次方</li></ul><h3 id="所以浮点数的通用表示格式如下" tabindex="-1">所以浮点数的通用表示格式如下 <a class="header-anchor" href="#所以浮点数的通用表示格式如下" aria-label="Permalink to &quot;所以浮点数的通用表示格式如下&quot;">​</a></h3><p><img src="'+O+'" alt="图片"></p><ul><li>S代表尾数</li><li>r代表基数</li><li>j代表阶码 这里需要注意的是，浮点数的加减运算，并不是像我们上面介绍的那样简单，会经过以下几个步骤完成 <img src="'+R+'" alt="图片"></li></ul><p>这些名词大家感兴趣的话，可以去网上查询，我们只要了解到浮点数加减运算很麻烦就行了，但如果你要做一个浮点数运算的库，你肯定是要完全掌握的。</p><h2 id="_6、局部性原理和catche-缓存" tabindex="-1">6、局部性原理和catche(缓存) <a class="header-anchor" href="#_6、局部性原理和catche-缓存" aria-label="Permalink to &quot;6、局部性原理和catche(缓存)&quot;">​</a></h2><p>先看下图 <img src="'+B+`" alt="图片"></p><p>（说明一下，MDR和MAR虽然逻辑上属于主存，但是在电路实现的时候，MDR和MAR离CPU比较近） 上图是在执行一串代码,可以理解为js的for循环</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们可以发现</p><ul><li><p>数组的数据有时候在内存是连续存储的</p></li><li><p>如果我们要取数据，比如从内存取出a[0]的数据需要1000ns(ns是纳秒的意思),那么取出a[0]到a[7]就需要1000 * 8 = 8000 ns</p></li><li><p>如果我们cpu发现这是取数组数据，那么我就把就近的数据块a[0]到a[7]全部存到缓存上多好，这样只需要取一次数据，消耗1000ns cahce就是局部性原理的一个应用 <img src="`+M+'" alt="图片"></p></li><li><p>空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的</p></li><li><p>时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息 <img src="'+U+'" alt="图片"></p></li></ul><p>可以看到cache一次性取了a[0]到a[9]存储体上的数据，只需要1000ns，因为Cache是高速存储器，跟cpu交互速度就比cpu跟主存交互速度快很多。 接下里，进入最后一节(略过对总线知识的学习)，I/O设备的演变</p><h2 id="_7、i-o设备的演变" tabindex="-1">7、I/O设备的演变 <a class="header-anchor" href="#_7、i-o设备的演变" aria-label="Permalink to &quot;7、I/O设备的演变&quot;">​</a></h2><h3 id="i-o是什么呢" tabindex="-1">I/O是什么呢？ <a class="header-anchor" href="#i-o是什么呢" aria-label="Permalink to &quot;I/O是什么呢？&quot;">​</a></h3><p>输入/输出（Input /Output ,简称I/O），指的是一切操作、程序或设备与计算机之间发生的数据传输过程。 复制代码 比如文件读写操作，就是典型的I/O操作。接下来我们看一下I/O设备的演进过程 <img src="'+T+'" alt="图片"></p><h3 id="接着看第二阶段" tabindex="-1">接着看第二阶段 <a class="header-anchor" href="#接着看第二阶段" aria-label="Permalink to &quot;接着看第二阶段&quot;">​</a></h3><p><img src="'+S+'" alt="图片"></p><ul><li>为了解决第一阶段CPU要等待I/O设备，串行的工作方式，所有I/O设备通过I/O总线来跟CPU打交道，一旦某个I/O设备完成任务，就会以中断请求的方式，通过I/O总线，告诉CPU，我已经准备好了。</li><li>但是对于高速外设，它们完成任务的速度很快，所以会频繁中断CPU, 为了解决这个问题，高速外设跟主存之间用一条直接数据通路，DMA总线连接，CPU只需要安排开始高速外设做什么，剩下的就不用管了，这样就可以防止频繁中断CPU。 最后来看一下第三阶段 <img src="'+V+'" alt="图片"></li></ul><h3 id="第三阶段-cpu通过通道控制部件来管理i-o设备-cpu不需要帮它安排任务-只需要简单的发出启动和停止类似的命令-通道部件就会自动的安排相应的i-o设备工作" tabindex="-1">第三阶段，CPU通过通道控制部件来管理I/O设备，CPU不需要帮它安排任务，只需要简单的发出启动和停止类似的命令，通道部件就会自动的安排相应的I/O设备工作 <a class="header-anchor" href="#第三阶段-cpu通过通道控制部件来管理i-o设备-cpu不需要帮它安排任务-只需要简单的发出启动和停止类似的命令-通道部件就会自动的安排相应的i-o设备工作" aria-label="Permalink to &quot;第三阶段，CPU通过通道控制部件来管理I/O设备，CPU不需要帮它安排任务，只需要简单的发出启动和停止类似的命令，通道部件就会自动的安排相应的I/O设备工作&quot;">​</a></h3>',77);function j(L,Q,X,H,W,Y){const t=a("ArticleMetadata"),e=a("ClientOnly");return l(),o("div",null,[G,s(e,null,{default:r(()=>[s(t)]),_:1}),N])}const z=p(J,[["render",j]]);export{$ as __pageData,z as default};
